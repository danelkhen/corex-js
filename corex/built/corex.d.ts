declare module "array" {
    export class ArrayEx<T> extends Array<T> {
        private list;
        constructor(list: Array<T>);
        forEachJoin(action: any, actionBetweenItems: any): void;
        first(predicate: any): T;
        toArray(): T[];
        insert(index: any, item: any): void;
        insertRange(index: any, items: any): void;
        last(predicate: any): T;
        toObject(selector: any): Object;
        toObjectKeys(defaultValue: any): {};
        copyPairsToObject(obj?: Object): Object;
        removeFirst(): T;
        remove(item: any): boolean;
        removeRange(items: any): void;
        contains(s: any): boolean;
        containsAny(items: any): any;
        any(predicate: any): boolean;
        distinct(keyGen?: any): any[];
        removeAll(predicate: any, thisArg?: any): void;
        removeAt(index: any): void;
        forEachAsyncProgressive(actionWithCallback: any, finalCallback: any): void;
        where(predicate: any): T[];
        whereEq(selector: any, value: any): T[];
        whereNotEq(selector: any, value: any): T[];
        firstEq(selector: any, value: any): T;
        firstNotEq(selector: any, value: any): T;
        addRange(items: any): void;
        diff(target: any): {
            added: T[];
            removed: any;
        };
        hasDiff(target: any): boolean;
        _forEachAsyncProgressive(actionWithCallback: any, finalCallback: any, index: any): void;
        mapAsyncProgressive(actionWithCallback: any, finalCallback: any): void;
        _mapAsyncProgressive(actionWithCallbackWithResult: any, finalCallback: any, index: any, results: any): void;
        mapWith(anotherList: any, funcForTwoItems: any): any[];
        min(): any;
        max(): any;
        getEnumerator(): any;
        orderBy(selector: any, desc: any, comparer?: any): any;
        orderByDescending(selector: any, desc: any): any;
        sortBy(selector: any, desc?: any, comparer?: any): this;
        sortByDescending(selector: any): this;
        mapAsyncParallel(asyncFunc: any, finalCallback: any): void;
        forEachAsyncParallel(asyncFunc: any, finalCallback: any): void;
        clear(): void;
        itemsEqual(list: any): boolean;
        select(selector: any): {}[];
        selectInvoke(name: any): any[];
        joinWith(list2: any, keySelector1: any, keySelector2: any, resultSelector: any): any[];
        all(predicate: any): boolean;
        flatten(): any[];
        selectToObject(keySelector: any, valueSelector: any): {};
        groupByToObject(keySelector: any, itemSelector?: any): {};
        groupBy(keySelector: any, itemSelector: any): any;
        splitIntoChunksOf(countInEachChunk: any): any[];
        avg(): number;
        selectMany(selector: any): any[];
        sum(): number;
        skip(count: any): T[];
        take(count: any): T[];
        toSelector(): any;
        removeNulls(): void;
        exceptNulls(): T[];
        truncate(totalItems: any): void;
        random(): T;
        selectRecursive(selector: any, recursiveFunc: any): {}[];
        selectManyRecursive(selector: any, recursiveFunc: any): any;
        forEachWith(list: any, action: any): any;
        selectWith(list: any, func: any): any;
        crossJoin(list2: any, selector: any): any[];
        static joinAll(lists: any, keySelector: any, resultSelector: any): any[];
        static outerJoin(list1: any, list2: any, keySelector1: any, keySelector2: any, resultSelector: any): ArrayEx<any>;
        static outerJoinAll(lists: any, keySelector: any, resultSelector: any): any[];
        static forEachAll(lists: any, action: any): void;
        static selectAll(lists: any, func: any): any[];
        static forEachTwice(list1: any, list2: any, action: any): void;
        static selectTwice(list1: any, list2: any, func: any): any[];
        static generate(length: any, generator: any): any[];
        static wrapIfNeeded(obj: any): any[];
        static toArray(arrayLike: any): any;
        static from<T>(x: T[]): ArrayEx<T>;
        static generateNumbers(from: any, until: any): any[];
        static fromIterator(iterator: any): any[];
    }
}
declare class Q {
    static copy<T>(source: T, target2?: T, options?: any, depth?: any): T;
    static objectValuesToArray(obj: any): any[];
    static cloneJson(obj: any): any;
    static forEachValueInObject(obj: any, func: any, thisArg: any): void;
    static mapKeyValueInArrayOrObject(objOrList: any, func: any, thisArg: any): any[];
    static jMap(objOrList: any, func: any, thisArg: any): any[];
    static isEmptyObject(obj: any): boolean;
    static min(list: any): any;
    static max(list: any): any;
    static stringifyFormatted(obj: any): any;
    static _canInlineObject(obj: any): any;
    static _canInlineArray(list: any): boolean;
    static stringifyFormatted2(obj: any, sb: any): void;
    static bindFunctions(obj: Object): void;
    static parseInt(s: any): number;
    static parseFloat(s: any): number;
    static createSelectorFunction<T, R>(selector: any): any;
    static isNullOrEmpty(stringOrArray: any): boolean;
    static isNotNullOrEmpty(stringOrArray: any): boolean;
    static isNullEmptyOrZero(v: any): boolean;
    static isAny(v: any, vals: any): any;
}
